# stm32学习笔记
## 目录
- [stm32学习笔记](#stm32学习笔记)
  - [目录](#目录)
  - [STM32总体情况](#stm32总体情况)
    - [STM32片上资源及其外设一览](#stm32片上资源及其外设一览)
    - [命名规则](#命名规则)
    - [系统结构](#系统结构)
    - [引脚定义](#引脚定义)
    - [引脚启动模式](#引脚启动模式)
    - [常见电子模块结构](#常见电子模块结构)
  - [GPIO（General Purpose Input Output）通用输入输出口](#gpiogeneral-purpose-input-output通用输入输出口)
    - [基本结构](#基本结构)
    - [位结构](#位结构)
      - [输入部分](#输入部分)
      - [输出部分](#输出部分)
    - [GPIO模式](#gpio模式)
    - [GPIO配置寄存器](#gpio配置寄存器)
      - [端口配置低/高寄存器](#端口配置低高寄存器)
      - [端口输入输出数据寄存器](#端口输入输出数据寄存器)
      - [端口位设置/清除寄存器`(Port Bit Set/Reset Register)`](#端口位设置清除寄存器port-bit-setreset-register)
  - [注：如果同时设置了BSy和BRy的对应位，BSy位起作用。](#注如果同时设置了bsy和bry的对应位bsy位起作用)
      - [端口配置锁定寄存器`(Port Configuration Lock Register)`](#端口配置锁定寄存器port-configuration-lock-register)
        - [实例: *锁定 PA0 引脚的配置*](#实例-锁定-pa0-引脚的配置)
        - [实例: *封装成函数*](#实例-封装成函数)
  - [STM32外设及其电路](#stm32外设及其电路)
    - [LED 和 蜂鸣器](#led-和-蜂鸣器)
      - [基础常识](#基础常识)
      - [硬件电路~(电阻R1防止电流过大,还能调节功率)~](#硬件电路电阻r1防止电流过大还能调节功率)
        - [三极管](#三极管)
  - [真是对苦命鸳鸯!](#真是对苦命鸳鸯)
    - [面包板](#面包板)
  - [使用库函数的一些方法](#使用库函数的一些方法)
    - [头文件,寻声明](#头文件寻声明)
    - [库函数用户手册](#库函数用户手册)

## STM32总体情况
### STM32片上资源及其外设一览
![](./images/2026-01-19-20-02-48.png)

### 命名规则
![](./images/2026-01-19-20-04-27.png)
从左到右分别是
产品系列    产品类型    产品子类型   引脚数目    闪存储存器容量  封装    温度范围

### 系统结构
![](./images/2026-01-19-20-10-06.png)

### 引脚定义
![引脚定义](./images/2026-01-19-20-11-03.png)

### 引脚启动模式
![](./images/2026-01-19-20-12-07.png)

### 常见电子模块结构
![](./images/2026-01-19-20-12-52.png)

##  GPIO（General Purpose Input Output）通用输入输出口
可配置为8种输入输出模式
引脚电平：0V~3.3V，部分引脚可容忍5V
>这里的容忍是能接收5V的意思，对于输出而言，最大只能输出3.3V,因为供电只有3.3V
能容忍5V的引脚会带FT标志,(Five Tolerate)

`输出模式`下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等
`输入模式`下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等
>核心是通过输入和输出高低电平和电压实现信息的读取和传达

### 基本结构
![](./images/2026-01-19-19-59-22.png)
向上看,在STM32里,所有`GPIO`都挂载在`APB2外设总线`上,而`APB2外设总线`可以在[系统结构](#系统结构)的中左方找到.
向下看,每个GPIO外设都有16个引脚,编号是0-15~(什么索引笑话)~
每个引脚的命名就是显而易见的`PA0` `PA1`...

GPIO模块内主要包含**寄存器**和**驱动器**
**寄存器**就是一种比较特殊的存储器,内核可以通过APB2总线对寄存器进行读写,进而实现输出电平和读取电平.
**寄存器**的每一位对应一个引脚,当输出寄存器写1,对应引脚就会输出高电平,写0就会输出低电平. 而输入寄存器的读取亦然.
>STM32是32位微处理器,所以寄存器也是32位的, 但是寄存器端口只有16位,所以只有低16位有对应端口  

驱动器用来增加信号的驱动能力, 这样一来, 寄存器只需要存储数据,而进行操作,则需要驱动器增大驱动能力.

### 位结构
![](./images/2026-01-19-20-36-26.png)
*横着看*, 左中边部分是**寄存器**,中间部分是**驱动器**,右边部分是具体的一个IO引脚.
*竖着看*, 上面是**输入部分**,下面是**输出部分**.

#### 输入部分
- **保护二极管**(看IO引脚, 这里接了两个),对输入电压进行限幅
上面的二极管接`VDD`3.3V,下面的二极管接`VSS`0V
如果电压大于3.3V,就会流向VDD,避免对GPIO的内部电路造成伤害; 小于0V,就流向VSS

- **上拉电阻和下拉电阻**(中上方),两者的开闭可由程序配置.
>上拉和下拉的作用:  给输入提供一个默认的输入电平
对应一个数字的端口(引脚),其输入不是高电平就是低电平.但是这是引脚有输入的情况,如果引脚没输入, 那算高电平还是低电平呢?
实际情况里, 这时的输入就会处于一种浮空的状态,输入电平极易受外界干扰而改变.
所以,**上下拉电阻的作用就是保证引脚悬空时的默认电平高低**. 

上下拉电阻的阻值很大,是一种弱上拉和弱下拉,目的是尽量不影响正常的输入操作.

- **施密特触发器**(中上方),~图中的肖特基触发器是翻译错误~,目的是为了对输入电压进行整形.
>原因:
引脚的输入是数字信号,但是实习情况里可能会产生各种失真,所以信号是无规则的波形.
执行逻辑:
如果输入电压大于某一阈值,则输出瞬间为**设定好的高电压值**,直到低于某一阈值,则瞬间降为低电平.反之亦然.

- **输入数据寄存器**IDR（Input Data Register）
  经过整形的信息就可以写入输入数据寄存器了,之后我们通过程序读取输入数据寄存器对应的某一位数据后,就可以知道端口的输入电平了.

- **外设输入**(左上方)
将输入连接到片上外设的一些端口上
模拟输入--连接到ADC上,需要模拟量,所以要连在施密特触发器前面
复用功能输入--连接其他端口上(比如串口的输入引脚),要接收数字量,所以在施密特触发器前面.

#### 输出部分

- **输出数据寄存器**ODR（Output Data Register）或者**片上外设控制**
两种控制部分输出数字量,通过**数据选择器**~（就是那个梯形）~接到**输出控制**部分
>如果通过**输出数据寄存器**进行输出,就是普通的IO口输出.写此寄存器的某一位就可以操作相应端口了

- 位设置/清除寄存器~(两个不同的寄存器)~
用来单独操作输出数据寄存器的某一位,**不会影响其他位**
>原因:
**输出数据寄存器**同时控制16个端口, 并且这个寄存器**只能整体读写**
想只更改某一位的话,需要先读取寄存器,然后用按位与(&=)和按位或(|=)的方式,指定更改某一位,然后写回去.
麻烦,效率低下.

所以我们就可以通过**位设置/清除寄存器**来解决这个问题:
>方法:
如果我们要对**输出数据寄存器**某一位进行 *置1* 操作,只要在**位设置寄存器**的对应位 *写1* 即可,剩下位写0.
这样操作后,**位设置寄存器**内部电路会自动将输出数据寄存器的对应位 *置1*,*写0*位不变.

>如果我们要对**输出数据寄存器**某一位进行 *清0* 操作,只要在**位清除寄存器**的对应位 *写0* 即可,剩下位写1.
这样操作后,**位清除寄存器**内部电路会自动将输出数据寄存器的对应位 *置0*,*写1*位不变.

一步到位,简单高效.
听懂掌声()
此外,还有一种操作方式----读写STM32的"位带"区域
  
- - 什么是位带?
在STM32中,专门分配的有一段地址区域,**用来映射RAM和外设寄存器的所有位**.
所以,通过读取这段地址中的数据,相当于读写相应映射位.
主要用于基于寄存器的开发方式中.

而基于库函数的开发方式,使用的还是前两种方式.

- **MOS管**
MOS管,作用类似于开关,,负责将IO口接到VDD还是VSS,我们先前的数字信息就是用来控制此处的导通和关闭的.
此处有三种输出模式----推挽, 开漏 和 关闭:
-  - 推挽输出模式
P-MOS和 N-MOS 均有效:
寄存器对应位*置1*时,上管导通,下管断开,输出连接VDD,输出高电平.
寄存器对应位*置0*时,上管导通,下管断开,输出连接VSS,输出低电平.
>高低电平都有较强的驱动能力,所以推挽输出模式又叫**强推输出模式**
该模式下.STM32对IO口有绝对的控制权,高低电平由STM32说的算

-  - 开漏输出模式
P-MOS无效,只有N-MOS能工作.
寄存器对应位*置1*时,上下管断开,输出断开,呈高阻模式.
寄存器对应位*置0*时,上管导通,下管断开,输出连接VSS,输出低电平.
>只有低电平有驱动能力,高电平没有驱动能力.
**开漏模式可以作为通信协议的驱动方式**,原因是多机通信时可以避免多设备的相互干扰
并且,**开漏模式可以用于输出指定电压的电平信号,以兼容一些设备**,只要在IO口外额外加一个连接指定电压的上拉电阻就行利用上拉电阻`无电压我称王的特性`

- - 关闭输出模式
P-MOS,N-MOS都无效.端口电平完全取决于外部信号.

### GPIO模式
通过配置GPIO的端口配置寄存器，端口可以配置成以下8种模式:
![](./images/2026-01-20-02-41-34.png)
当我们配置完端口配置寄存器的模式,[位结构](#位结构)的电路也会随之改变
变化部分比如 **上下拉电阻的选择**,**MOS管的通断**,**数据选择器的选择**,**施密特触发器的开关**

>输出模式下,输入模式也是有效的,但是输入模式下,输出都是无效的
这是因为一个端口可以有多个输入,但只能有一个输出.
且,输入模式下,输出模式的**MOS管**被设置为断开,而输出模式下,并不会断开**施密特触发器**
目的是安全,多个输出会损坏电路

### GPIO配置寄存器
在 STM32（尤其是 STM32F1 系列）中，每个 GPIO 端口（如 GPIOA、GPIOB...）都有一组控制寄存器，其中：
| 寄存器缩写 | 全称 | 作用 |
|-----------|------|------|
| CRL | Port Configuration Register Low | 配置 引脚 0～7 的工作模式（输入/输出、速度、上下拉等） |
| CRH | Port Configuration Register High | 配置 引脚 8～15 的工作模式 |
| ODR | Output Data Register | 控制 所有 16 个引脚 的输出电平（高/低） |
#### 端口配置低/高寄存器
此处的高低是指其配置的端口的序号高低

![](./images/2026-01-20-03-17-00.png)
![](./images/2026-01-20-03-17-54.png)
每个端口用4位配置,16个端口所以需要两个32位的寄存器进行配置

---
![](./images/2026-01-20-03-22-55.png)
每个端口的前两位是模式位,控制一个引脚的 **工作模式与速度**
后两位是配置位,控制一个引脚的**输入/输出类型或复用功能**
也可以见得,模式位会影响配置位的模式

---
#### 端口输入输出数据寄存器
![](./images/2026-01-20-17-19-18.png)

![](./images/2026-01-20-17-19-59.png)

---
#### 端口位设置/清除寄存器`(Port Bit Set/Reset Register)`

![](./images/2026-01-20-17-23-38.png)
>低16位位设置，高16位位清除
注：如果同时设置了BSy和BRy的对应位，BSy位起作用。
---
![](./images/2026-01-20-17-31-11.png)
![](./images/2026-01-20-17-32-16.png)
>此寄存器的低16位和`8.2.5`的寄存器的高16位功能一样
这个寄存器的设计哲学是方便操作 :
如果只想单一的进行位设置和位清除
那就位设置就用`8.2.5`,位清除就用`8.2.6`
这就保证了位设置和位清除使用的都是低16位的数据.这样方便一些

>但如果想对多个端口进行位设置和位清除,那就使用`8.2.5`,保证了位清除和位设置的**同步性**.

#### 端口配置锁定寄存器`(Port Configuration Lock Register)`

![](./images/2026-01-20-17-46-52.png)
- **操作指南**
-  - 原理
只有当 CPU 在 1 个 APB1/2 时钟周期内 执行`LCKK = 1 → LCKK = 0 → LCKK = 1`写入序列时，同时，低 16 位（LCK[15:0]）必须保持不变,这样锁定才会生效.
##### 实例: *锁定 PA0 引脚的配置*
```C
  // 锁定 PA0 的配置（模式、上下拉等）
GPIOA->LCKR = (1 << 0) | (1 << 16);   // LCK0=1, LCKK=1
GPIOA->LCKR = (1 << 0);               // LCK0=1, LCKK=0
GPIOA->LCKR = (1 << 0) | (1 << 16);   // LCK0=1, LCKK=1

// 读取 LCKK 位确认是否锁定成功
if ((GPIOA->LCKR & (1 << 16)) != 0) {
  // 锁定成功！PA0 配置已锁定，直到复位
  // 函数体
}
```
- - 逐行分析:
  
第一次赋值
```C
GPIOA->LCKR = (1 << 0) | (1 << 16);   // LCK0=1, LCKK=1
```
(1 << 0) → 设置 Bit 0 = 1，此时值为0x00000001
(1 << 16) → 设置 Bit 16 (LCKK) = 1,此时值为0x00010000
当通过按位或`|`运算后, **有一则一**
整体写入值：0x00010001
效果：告诉硬件：“锁定 PA0 *(LCK0=1)*，并且现在开始锁定序列的第一步 *(LCKK=1)*”

---
再次赋值
```C
GPIOA->LCKR = (1 << 0);               // LCK0=1, LCKK=0
```
(1 << 0) → Bit 0 = 1（仍然表示锁定 PA0）
没有设置 Bit 16 → 所以 LCKK = 0
写入值：0x00000001
效果：完成锁定序列的第二步（LCKK=0），且保持 LCK0=1 不变
>注意：如果这里把 LCK0 改成 0，序列就无效！

---
再再赋值
```C
GPIOA->LCKR = (1 << 0) | (1 << 16);   // LCK0=1, LCKK=1
```
再次写入 LCK0=1 和 LCKK=1（值 0x00010001）
效果：完成第三步（LCKK=1）
>此时，STM32 的 GPIO 硬件检测到完整的 1→0→1 序列 + LCK[0]=1 始终不变，于是：
立即锁定 PA0 的配置寄存器（如 MODER、OTYPER、PUPDR 等）
LCKK 位被硬件自动置为 1 并保持（直到复位）

---
读取 LCKK 位,以确认是否锁定成功
```C
// 读取 LCKK 位确认是否锁定成功
if ((GPIOA->LCKR & (1 << 16)) != 0) {
    // 锁定成功！PA0 配置已锁定，直到复位
}
```
读取 GPIOA->LCKR 的值
用 & (1 << 16) 检查 Bit 16（LCKK）是否为 1
如果为 1 → 表示锁定已生效
如果为 0 → 锁定失败（比如序列没对齐、时序被打断等）

---
- - 锁定后会发生什么？

PA0 的配置被冻结：
你不能再修改它的：
- 模式（输入/输出/复用）
- 上拉/下拉电阻
- 输出类型（推挽/开漏）
- 速度等
任何后续对 GPIOA->MODER、PUPDR 等寄存器中 PA0 相关位的**写操作 都会被忽略**

但输出电平仍可改:
只要 PA0 是输出模式，仍可**通过 BSRR 或 ODR 控制高低电平**.

##### 实例: *封装成函数* 
```C
void lock_gpio_pins(GPIO_TypeDef* gpio, uint16_t pin_mask) {
    __IO uint32_t tmp;
    gpio->LCKR = pin_mask | GPIO_LCKR_LCKK;  // LCKK=1
    gpio->LCKR = pin_mask;                   // LCKK=0
    gpio->LCKR = pin_mask | GPIO_LCKR_LCKK;  // LCKK=1
    tmp = gpio->LCKR;                        // 读一次（必须！）
    (void)tmp;                               // 防止编译器优化
}

// 使用：锁定 PA5 和 PA6
lock_gpio_pins(GPIOA, GPIO_PIN_5 | GPIO_PIN_6);
```
- - **逐行分析**:

函数声明
```C
void lock_gpio_pins(GPIO_TypeDef* gpio, uint16_t pin_mask)
```
`gpio`：指向某个 GPIO 端口的寄存器基地址（如 GPIOA, GPIOB）
`pin_mask`：要锁定的引脚位掩码（如 GPIO_PIN_5 | GPIO_PIN_6 表示 PA5 和 PA6）

---
```C
__IO uint32_t tmp;
```
`__IO` 是 STM32 标准库中定义的宏，通常等价于 `volatile`。
这行的功能是----**声明一个 易失性（volatile）临时变量 tmp**。
目的：用于后续读取 LCKR 寄存器，**防止编译器优化掉这个“看似无用”的读操作。**
- `volatile`的设计哲学
- - 背景与困境
在嵌入式开发中，程序不仅和 CPU 交互，还直接操作硬件寄存器（比如你之前问的 GPIO 寄存器）、中断服务函数、多线程 / 多核心共享变量—— 这些**数据的取值可能 “不受程序控制” 地被硬件 / 外部因素修改**~比如温度湿度检测,数据由外界决定~
而 C 语言编译器有一个优化策略：把**频繁访问的变量缓存到寄存器中**（而不是每次都从内存读取），以提升执行效率。**但这个优化对 “会被外部因素修改的变量” 是致命的 —— 编译器会误以为变量值没变化，导致程序逻辑错误。**~外部因素修改后的变量值放在内存里,而编译器每次都读寄存器里的缓存值,结果产生错误~
- - 作用
volatile 的核心作用就是：告诉编译器 “这个变量是易变的，**不要对它做任何优化**！**每次读写都必须直接访问内存（硬件寄存器），不能缓存到 CPU 寄存器**”

- - 为什么需要 `volatile`？
因为普通变量如果只写不读，编译器会认为“没用”，直接优化没掉。但这里读 LCKR 是硬件要求的动作，必须保留！
同时,在嵌入式开发中，**所有与硬件交互的临时变量都习惯用 volatile**
这样一眼看出：`“这个变量和硬件状态有关”`

- - 注:
gpio->LCKR 本身是 **volatile**（在 STM32 头文件中已定义）

---
```C
gpio->LCKR = pin_mask | GPIO_LCKR_LCKK;  // 前面已经写过
// #define GPIO_PIN_0   ((uint16_t)0x0001) or (1 << 0)
// # difine GPIO_LCKR_LCKK (1 << 16)。
```
将用户指定的引脚`pin_mask`(如 ~0x0060=(0x0020|0x0040)~ 对应 PA5+PA6)与 LCKK 位（Bit 16） 合并。
写入后，LCKR 的低 16 位 = 要锁定的引脚，Bit 16 = 1。
这是 锁定序列的第一步：LCKK = 1

---
完成锁定序列的第二步（LCKK=0），且保持 pin_mask 不变
```c
gpio->LCKR = pin_mask;                   // LCKK=0
```

---
完成第三步（LCKK=1）,开启锁定引脚配置
```C
gpio->LCKR = pin_mask | GPIO_LCKR_LCKK;  // LCKK=1
```

---
从 LCKR 寄存器读取一次值，存入 tmp。
```C
tmp = gpio->LCKR;                        // 读一次（必须！）
```
- 为什么必须读？
- - 在 某些 STM32 型号（尤其是早期 F1 系列） 中，只有在第三次写入后立即读取 LCKR，硬件才会真正完成锁定。
- - 这是一个 硅片级别的设计要求（参考 RM0008 手册）。
- - 即使新芯片可能不需要，加上更安全、兼容性更好。

---
防止被优化
```c
(void)tmp;                               // 防止编译器优化
```
显式告诉编译器：“我知道 `tmp` 没被使用，但别删它！”
如果没有这行，高优化级别（如 -O2, -O3）下，编译器可能认为 tmp 无用，连带把上一行的读操作也优化掉！
`(void)tmp;` 是 C 语言中抑制 “unused variable” 警告的标准做法。
>这两行组合确保：读操作一定会被执行，不会被优化掉。

---
- - **总结**:

| 设计点 | 原因 |
|-------|------|
| 用函数封装 | 避免重复写三步序列，提高可读性和复用性 |
| 加 `tmp` 读操作 | 兼容所有 STM32 型号，确保锁定生效 |
| 加 `(void)tmp` | 防止编译器优化掉关键读操作 |
| 参数化 `gpio` 和 `pin_mask` | 支持任意端口（A/B/C...）和任意引脚组合 |

## STM32外设及其电路
### LED 和 蜂鸣器
#### 基础常识
- LED：发光二极管，正向通电点亮，反向通电不亮
没剪过的LED中,长脚是正极,短脚是负极;也可以看LED内部,较小一半是正极,较大一半是负极
![](./images/2026-01-20-21-55-41.png)
- 有源蜂鸣器：内部**自带振荡源**，将正负极接上**直流电压**即**可持续发声，频率固定**
VCC接正极,GND(ground)接负极
中间引脚接低电平,蜂鸣器就响,接高电平,蜂鸣器就关闭
![](./images/2026-01-20-21-56-03.png)
- 无源蜂鸣器：内部**不带振荡源**，需要控制器**提供振荡脉冲才可发声**，**调整**提供振荡脉冲的**频率**，**可发出不同频率的声音**

#### 硬件电路~(电阻R1防止电流过大,还能调节功率)~
- **LED**
低电平触发
![](./images/2026-01-20-22-05-37.png)
由二极管特性和电压高低决定,懂得都懂

---
高电平触发
![](./images/2026-01-20-22-06-11.png)
一般选第一种`低电平驱动`,因为很多单片机和芯片都使用的是高电平弱驱动,低电平强驱动的模式~(比如开漏输出,此时高电平无用)~

- **蜂鸣器**
使用了三极管开关的驱动方案
对于功率大一点的外设,如果直接用IO口驱动会导致STM32负担过重.这时就可以用一个三极管驱动电路来完成驱动,这里要先介绍一下三极管:
##### 三极管
三极管（晶体管）是电子电路中最基础、最重要的半导体器件之一，主要用于**放大信号**和**开关控制**
- **三极管的类型**

| 类型 | 全称 | 结构 | 符号特点 |
|------|------|------|--------|
| NPN | N-P-N 型 | 两层 N 型夹一层 P 型 | 箭头向外（从基极指向发射极） |
| PNP | P-N-P 型 | 两层 P 型夹一层 N 型 | 箭头向内（发射极指向基极） |
>箭头就是 发射极电流 IE 的方向.

| 类型 | 掺杂元素 | 多数载流子 | 特点 |
|:------:|--------|-----------|------|
| N 型 | 磷（P）、砷（As）等（5价元素） | 电子（负电荷） | “N” = Negative（负） |
| P 型 | 硼（B）等（3价元素） | 空穴（等效正电荷） | “P” = Positive（正） |
|N 型：多出自由电子 → 导电靠 电子流动|
|P 型：缺少电子（形成“空穴”）→ 导电靠 空穴移动|

| 对比项 | NPN | PNP |
|-------|-----|-----|
| 控制逻辑 | GPIO 高电平 → 导通 | GPIO 低电平 → 导通 |
| 接法 | 负载接 Vcc → C，E 接 GND | 负载接 E，C 接 GND |
| 常用场景 | 低边开关（Low-side switch） | 高边开关（High-side switch） |
PNP:
![](./images/2026-01-20-22-08-10.png)
NPN:
![](./images/2026-01-20-23-02-13.png)
- **三个引脚**
以NPN举例

| 引脚 | 英文 | 作用 |
|:----:|-----|------|
| B | Base（基极） | 控制端：小电流输入，控制大电流 |
| C | Collector（集电极） | 接电源正（负载端） |
| E | Emitter（发射~(载流子)~极） | 接地（GND） |
|口诀： “基极控流，集电进，发射出~(载流子)~”|

- **工作原理**
  - **核心思想**
用小电流（IB）控制大电流（IC）
满足关系：IC = β × IB
（β 是电流放大倍数，典型值 50～300）
  - **工作状态**(以NPN举例----**无能的基极**)
![](./images/2026-01-20-23-30-53.png)
![](./images/2026-01-20-23-52-15.png)
未通电时,E富集电子,B较多空穴.
B E之间开始有电压后, 空穴被电子占据(进入空穴,意味着将要流向B区);
V<sub>BE</sub>随着越来越大,空穴容纳不下所有的电子.
此时V<sub>CE</sub>开始有了电压,促使基极区的多余电子跑到了集电极去,使得CE间也有了电流,此时,B区的电流是IB,  C区的电流是IC, E区的电流是(IB+IC).

| 状态 | 条件（NPN） | 特点 | 应用 |
|------|-------------|------|------|
| 截止区 | V<sub>BE</sub> < 0.7V | IB ≈ 0，IC ≈ 0 → 关断 | 开关“断开” |
| 放大区 | V<sub>BE</sub> ≈ 0.7V，V<sub>CE</sub> > V<sub>BE</sub> | IC = β·IB，线性放大 | 音频放大、传感器信号放大 |
| 饱和区 | V<sub>BE</sub> ≈ 0.7V，V<sub>CE</sub> ≈ 0.2V | IC 不再随 IB 增大 → 完全导通 | 开关“闭合” |
>截止区 : 电压太小,BE间无法导通,所以IB ≈ 0，IC ≈ 0
放大区 : BE间导通,但空穴未被完全占满,此时由于概率关系,在空穴里的电子和未在空穴里的电子比例是恒定的.所以会说`IC = β × IB`
饱和区 : B区空穴被占满,不管多余电子全走CE电路,线性关系打破

>数字电路中，三极管只工作在 截止（0） 和 饱和（1） 两种状态，当作电子开关用。
- - 设计哲学
CE端之间隔着一层薄薄的B区,但是就是因此可望不可及;
当B区和E区开始载流子的交流后, E区的载流子才能偷偷流到B区去
真是对苦命鸳鸯!
---
![](./images/2026-01-20-22-08-10.png)
这个图里,是PNP三极管的驱动电路,
基极给低电平导通,高电平断开

---
![](./images/2026-01-20-23-02-13.png)
这个图里,是NPN三极管的驱动电路,
基极给高电平导通,低电平断开

### 面包板
面包板正面:
![](./images/2026-01-21-02-12-23.png)
面包板背面:
![](./images/2026-01-21-02-13-02.png)
面包板的上下各两行是电源线,每行的线路连通;
面包板的中间部分,每列5个孔通过金属爪连通.想实现外设通电,就将电源行上的孔连到中间列的孔上去
![](./images/2026-01-21-02-16-44.png)

## 使用库函数的一些方法
### 头文件,寻声明
![](./images/2026-01-22-02-52-52.png)
点击头文件,点击 "`open document`", 打开头文件;
你可以在所有的功能前都找到相应注释;
可以在头文件的前大半部分看见一系列的**宏定义`#define`, 以及类型定义`typedef`**,这是对抽象底层信息~(如地址)~的一种封装, 利于后期维护和优化时的理解;
可能在中间穿插几个**条件编译**;
然后可以在最后部分找到一堆**函数声明**;
![](./images/2026-01-22-03-06-35.png)
然后点击想用的函数的函数名,右键,点击"Go To Defination Of ";
![](./images/2026-01-22-03-09-01.png)

然后就可以跳转到函数实现,通过注释了解函数,参数的含义与取值;
![](./images/2026-01-22-03-11-35.png)

### 库函数用户手册
可以打开[STM32F103xx固件函数库用户手册](./datum/STM32F103xx固件函数库用户手册.pdf)
这里有所有库函数的介绍和使用方法;